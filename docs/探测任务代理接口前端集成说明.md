# 《探测任务代理接口前端集成说明》

## 一、接口概述
- 目标：前端通过 chaosblade-box-starter 作为代理层，调用“探测任务服务”能力，无需直连探测任务服务。
- 代理行为：透明转发。保持请求方法、路径、查询参数、请求头、请求体不变；将上游服务（探测任务服务）的响应原样返回（包括状态码与响应体）。
- 本文档覆盖接口（基于 docs/探测任务新增接口说明.md 原始规范）：
  - 获取系统信息列表（分页）
  - 获取指定系统的 API 信息
  - 获取指定 API 的拓扑结构
  - 获取故障类型列表
  - 创建探测任务


## 二、基础信息
- 前端调用基础 URL（示例）：`http://{starter-host}:7001`
- 路径前缀：无（保持与原始文档一致，直接使用 `/api/...`）
- 上游服务基础 URL（后端配置）：`probe.api.base-url`
  - 默认值：`http://1.94.151.57:8101`
  - 实际部署可通过环境配置覆盖，无需前端修改
- 转发规则（摘要）：
  - 请求：保留原始方法、路径、查询参数、请求头、请求体；仅移除 `Host`、`Content-Length`（由客户端计算）。
  - 响应：原样透传；仅不回传 `Content-Length`、`Transfer-Encoding`、`Connection` 这些由容器处理的头部。


## 三、详细接口列表
以下“前端端点”即 chaosblade-box-starter 对外提供的代理地址；其参数与响应与上游探测任务服务保持一致。

### 1. 获取系统信息列表（分页）
- 前端端点（代理层）：
  - `GET /api/systems`
  - 示例：`/api/systems?page=1&size=20`
- 请求参数：
  - 查询参数：
    - `page`（int）：页码（从 1 开始）
    - `size`（int）：每页大小
- 请求头（建议）：
  - `Accept: application/json`
  - `Cookie: <cookie-kv>`（例如：`JSESSIONID=<session-id>`，或其它会话 Cookie）
- 响应格式（示例，原样透传）：
  - 状态码：`200` 成功；`4xx/5xx` 为上游错误透传
  - Body（示例简化）：
    ```json
    {
      "success": true,
      "data": { "items": [ ... ], "total": 2, "page": 1, "size": 20, ... }
    }
    ```

### 2. 获取指定系统的 API 信息
- 前端端点（代理层）：
  - `GET /api/systems/{systemId}/apis`
  - 示例：`/api/systems/2/apis`
- 请求参数：
  - 路径参数：`systemId`（long/int）
  - 查询参数：如上游支持分页/过滤，可原样传入
- 请求头（建议）：
  - `Accept: application/json`
  - `Cookie: <cookie-kv>`（例如：`JSESSIONID=<session-id>`，或其它会话 Cookie）
- 响应格式（示例，原样透传）：
  - 状态码：`200` 成功；`4xx/5xx` 为上游错误透传
  - Body（示例简化）：
    ```json
    {
      "success": true,
      "data": { "items": [ ... ], "total": 1, "page": 1, "size": 50, ... }
    }
    ```

### 3. 获取指定 API 的拓扑结构
- 前端端点（代理层）：
  - `GET /api/topologies/{apiId}/nodes`
  - 示例：`/api/topologies/1/nodes`
- 请求参数：
  - 路径参数：`apiId`（long/int）
- 请求头（建议）：
  - `Accept: application/json`
  - `Cookie: <cookie-kv>`（例如：`JSESSIONID=<session-id>`，或其它会话 Cookie）
- 响应格式（示例，原样透传）：
  - 状态码：`200` 成功；`4xx/5xx` 为上游错误透传
  - Body（示例简化）：
    ```json
    {
      "success": true,
      "data": { "topology": { ... }, "nodes": [ ... ], "edges": [ ... ] }
    }
    ```

### 4. 获取故障类型列表
- 前端端点（代理层）：
  - `GET /api/fault-types`
- 请求参数：
  - 无固定必填查询参数；如需分页/过滤，按上游支持原样传入
- 请求头（建议）：
  - `Accept: application/json`
  - `Cookie: <cookie-kv>`（例如：`JSESSIONID=<session-id>`，或其它会话 Cookie）
- 响应格式（示例，原样透传）：
  - 状态码：`200` 成功；`4xx/5xx` 为上游错误透传
  - Body（示例简化）：
    ```json
    {
      "success": true,
      "data": { "items": [ { "faultTypeId": 10, "faultCode": "...", ... } ], ... }
    }
    ```

### 5. 创建探测任务
- 前端端点（代理层）：
  - `POST /api/probe-tasks`
- 请求参数：
  - 请求体（JSON）：与上游一致，代理不做任何修改
  - 示例（从原始文档抽取、可按需裁剪/调整）：
    ```json
    {
      "name": "TT-订票链路-容器移除-回归-2025-09-07",
      "description": "...",
      "systemId": 2001,
      "apiId": 1,
      "faultConfigurations": [ ... ],
      "taskSlo": [ ... ],
      "apiDefinition": { ... },
      "requestNum": 20
    }
    ```
- 请求头（建议）：
  - `Content-Type: application/json`
  - `Accept: application/json`
  - `Cookie: <cookie-kv>`（例如：`JSESSIONID=<session-id>`，或其它会话 Cookie）
- 响应格式：
  - 状态码：`200/201`（按上游实现）、`4xx/5xx` 透传
  - Body：上游原样返回


## 四、错误处理
- 代理层不改写错误，直接将上游的 `HTTP 状态码` 与 `响应体` 透传给前端。
- 常见情况：
  - 4xx：请求参数错误、鉴权失败等（由上游定义）。
  - 5xx：上游服务内部错误；或代理层连接/读取超时等导致的错误（可能返回框架默认错误体）。
- 前端建议：统一以“HTTP 状态码 + 响应体”的方式处理错误；优先尝试解析 JSON，失败再回退为文本。


## 五、与原始服务一致性说明
- 路径与方法：完全一致（/api/...；GET/POST 等）。
- 参数：路径参数、查询参数、请求体均原样透传。
- 请求头：除 `Host`、`Content-Length` 外全部保留（如 `Cookie`、`Accept`、`Content-Type`）。
- 响应：状态码与响应体均原样透传；响应头仅过滤容器相关头（`Content-Length`、`Transfer-Encoding`、`Connection`）。
- 因此，前端可直接以“原始接口规范”为准进行集成，而将调用地址指向 starter。


## 六、前端集成示例

### 1. curl 示例
- 获取系统信息：
  ```bash
  curl "http://{starter-host}:7001/api/systems?page=1&size=20" \
    -H "Accept: application/json" \
    -H "Cookie: JSESSIONID=<session-id>"
  ```
- 获取系统 API：
  ```bash
  curl "http://{starter-host}:7001/api/systems/2/apis" \
    -H "Accept: application/json" \
    -H "Cookie: JSESSIONID=<session-id>"
  ```
- 获取拓扑：
  ```bash
  curl "http://{starter-host}:7001/api/topologies/1/nodes" \
    -H "Accept: application/json" \
    -H "Cookie: JSESSIONID=<session-id>"
  ```
- 获取故障类型：
  ```bash
  curl "http://{starter-host}:7001/api/fault-types" \
    -H "Accept: application/json" \
    -H "Cookie: JSESSIONID=<session-id>"
  ```
- 创建探测任务：
  ```bash
  curl -X POST "http://{starter-host}:7001/api/probe-tasks" \
    -H "Content-Type: application/json" \
    -H "Accept: application/json" \
    -H "Cookie: JSESSIONID=<session-id>" \
    -d '{
      "name": "TT-订票链路-容器移除-回归-2025-09-07",
      "description": "...",
      "systemId": 2001,
      "apiId": 1,
      "faultConfigurations": [ ... ],
      "taskSlo": [ ... ],
      "apiDefinition": { ... },
      "requestNum": 20
    }'
  ```

### 2. JavaScript fetch 示例
- 创建探测任务：
  ```js
  const payload = {
    name: "TT-订票链路-容器移除-回归-2025-09-07",
    description: "...",
    systemId: 2001,
    apiId: 1,
    faultConfigurations: [ /* ... */ ],
    taskSlo: [ /* ... */ ],
    apiDefinition: { /* ... */ },
    requestNum: 20
  };

  fetch("http://{starter-host}:7001/api/probe-tasks", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Accept": "application/json"
    },
    credentials: "include", // 让浏览器携带 Cookie（跨域需服务端允许）
    body: JSON.stringify(payload)
  }).then(async (res) => {
    const text = await res.text();
    if (!res.ok) {
      // 优先尝试解析 JSON 错误体
      try { throw new Error(JSON.parse(text)); } catch (e) { throw new Error(text || res.statusText); }
    }
    try { return JSON.parse(text); } catch (e) { return text; }
  }).then((data) => {
    console.log("创建成功:", data);
  }).catch((err) => {
    console.error("创建失败:", err);
  });
  ```

### 3. 处理响应数据
- 成功：多数为 JSON，建议直接读取 `data/items/total` 等字段（以上游实际为准）。
- 失败：检查 `res.ok` 或 HTTP 状态码，解析响应体为 JSON 或文本并进行提示。


## 七、常见问题与注意事项
- CORS：starter 已设置跨域响应头。如浏览器触发预检（OPTIONS），请确保前端请求头与方法设置规范。
- 鉴权：若上游基于会话 Cookie（如 `JSESSIONID`），前端需确保浏览器携带 Cookie。跨域请求请设置 `credentials: "include"`（或 `withCredentials=true`），并确保服务端允许携带凭证。
- 参数编码：`systemId`、`apiId` 等路径变量如含特殊字符，请进行 URL 编码；查询参数保持与上游一致。
- Content-Type：创建任务建议使用 `application/json`。
- 超时与重试：starter 读取超时约 30s。如存在大响应/慢接口，请与后端确认上游 SLA；前端如需重试，请评估幂等性。
- 响应结构：代理层不做包装，完全取决于上游；前端应以“状态码 + 响应体”的方式健壮处理。


## 八、变更与扩展
- 如需扩展更多探测任务相关接口（如任务查询、执行、停止等），将按照相同原则在代理层暴露相同路径与方法，前端集成方式不变。

