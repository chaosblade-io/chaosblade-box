# 任务执行代理接口前端集成说明

本文档面向前端开发者，说明如何通过 chaosblade-box-starter 作为统一代理层，访问“任务执行”相关功能。代理层对外暴露固定 URL，并将请求原样转发到探测任务服务（svc-task-resource / svc-task-executor）。

- 认证与会话：使用 Cookie（如 JSESSIONID 等），无需携带 Authorization: Bearer。
- 代理策略：保持请求头、查询参数、路径参数、请求体原样透传；上游响应也不做任何包装与转换。

- 规范来源：以 docs/任务执行接口说明.md 为准。

---

## 一、基础信息
- 代理服务基址（可配置）：http://<starter-host>:<starter-port>
  - 实际转发目标基址由后端通过配置 `probe.api.base-url` 指向（默认 http://1.94.151.57:8101），前端无需关心。
- 前端一律调用 chaosblade-box-starter 暴露的以下路径。
- 所有接口均为无状态转发；带上必要的 Cookie 即可。

---

## 二、详细接口列表

### 1) 代理执行接口
- URL（代理层，固定）：POST /api/detection-tasks/{taskId}/execute
- 方法：POST
- 路径参数：
  - taskId(Long) 任务ID
- 查询参数：无（若有也会透传）
- 请求体：任意 JSON/文本，原样透传到执行器
- 请求头：建议至少包含 `Content-Type: application/json` 以及会话 Cookie
- 响应：原样返回上游执行器响应（通常为统一 ApiResponse）
- 可能状态码：
  - 200/201：执行请求已被接收
  - 4xx：请求参数/会话问题等
  - 5xx：上游异常或网络失败（代理层可能返回 502）

示例（curl）
```
curl -X POST \
  'http://starter-host:starter-port/api/detection-tasks/123/execute' \
  -H 'Content-Type: application/json' \
  -H 'Cookie: JSESSIONID=xxxxxx' \
  -d '{"options":{"dryRun":false}}'
```

JS fetch
```
await fetch('/api/detection-tasks/123/execute', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  credentials: 'include',
  body: JSON.stringify({ options: { dryRun: false } })
});
```

---

### 2) 任务执行详情（按 executionId）
- URL（代理层，固定，二选一）：
  - GET /api/task-executions/{executionId}
  - GET /api/executions/{executionId}
- 方法：GET
- 路径参数：
  - executionId(Long) 执行记录ID
- 查询参数：无（若传入亦会透传）
- 请求体：无
- 响应：统一 ApiResponse<ExecutionDetailsDto>
- 主要字段参考 docs/任务执行接口说明.md

示例（curl）
```
curl -X GET \
  'http://starter-host:starter-port/api/task-executions/567' \
  -H 'Cookie: JSESSIONID=xxxxxx'
```

JS fetch
```
const resp = await fetch('/api/task-executions/567', { credentials: 'include' });
const json = await resp.json();
```

---

### 3) 执行列表分页查询
- URL（代理层，固定，二选一）：
  - GET /api/task-executions
  - GET /api/executions
- 方法：GET
- 查询参数：
  - taskId(Long, 可选)
  - status(String, 可选)
  - namespace(String, 可选)
  - startDate(String, 可选，yyyy-MM-dd HH:mm:ss)
  - endDate(String, 可选，yyyy-MM-dd HH:mm:ss)
  - page(int, 默认1)
  - size(int, 默认20)
- 请求体：无
- 响应：统一 ApiResponse<PageResponse<TaskExecutionView>>

示例（curl）
```
curl -G 'http://starter-host:starter-port/api/task-executions' \
  -H 'Cookie: JSESSIONID=xxxxxx' \
  --data-urlencode 'status=DONE' \
  --data-urlencode 'namespace=default' \
  --data-urlencode 'page=1' \
  --data-urlencode 'size=20'
```

JS fetch
```
const url = new URL('/api/task-executions', window.location.origin);
url.searchParams.set('status', 'DONE');
url.searchParams.set('namespace', 'default');
url.searchParams.set('page', '1');
url.searchParams.set('size', '20');
const resp = await fetch(url.toString(), { credentials: 'include' });
const json = await resp.json();
```

---

## 三、请求头与会话
- 会话凭证采用 Cookie（例如 JSESSIONID），请在浏览器端使用 `credentials: 'include'`，或在 curl 中显式携带 Cookie。
- 透传策略：除 Host、Content-Length 由容器/框架处理外，其余请求头均会透传到上游；响应头除 Transfer-Encoding、Content-Length、Connection 其余也将透传。

## 四、错误处理
- 代理层不改写上游业务响应体，前端应直接按上游统一格式处理：
```
{
  "success": true|false,
  "data": ...,
  "error": {"code":"...","message":"...","details":{...}}
}
```
- 网络/连接异常时，可能返回 502 Bad Gateway，建议前端捕获并提示“上游服务不可用或网络异常”。

## 五、与原始服务的关系
- 代理层仅做转发与少量头部过滤，不参与鉴权与数据校验。
- 代理层路径与文档保持一致，确保前端无需直接访问探测任务服务即可完成任务执行相关操作。

## 六、常见问题与注意事项
1. 需要带 Token 吗？不需要，使用 Cookie 会话即可。
2. 跨域问题？前端与代理同域部署时无跨域；异域部署请确保网关或后端配置 CORS。
3. 为什么有两个别名路径？为兼容历史接口命名，任选其一即可，推荐 /api/task-executions 系列。
4. 时间参数格式错误会怎样？上游会返回统一的错误响应，请按 error.code / error.message 展示。
5. 大请求体/文件上传支持吗？当前接口以 JSON 为主，如需上传请与后端确认执行器支持的 Content-Type。

## 七、快速校验
- 打开浏览器控制台，执行：
```
fetch('/api/task-executions?page=1&size=10', { credentials: 'include' }).then(r=>r.json()).then(console.log)
```
应返回统一 ApiResponse 的分页对象。

